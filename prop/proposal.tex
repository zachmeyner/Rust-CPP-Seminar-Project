\documentclass[10pt]{IEEEtran}

\usepackage{multicol}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[OT1]{fontenc} 

\begin{document}
\title{Rust vs C++: Perforamnce in an extended sieve of Eratosthenes, an approximation of $\pi$ and and approximation of Euler's Number}
\author{\IEEEauthorblockN{Zachary Meyner}
\IEEEauthorblockA{} }
\date{}

\maketitle


Rust is a programming language maintained by Mozilla that is designed to maximize speed---in terms of time spent coding and 
execution---as well as safety. Rather than a garbage collector or manually managing memory safety of Rust is achieved 
through its system of ownership---a set of rules checked at compile time to ensure safety~\cite{rust2023}. The rules of ownership are:
\begin{itemize}
    \item Each value has an owner,
    \item Each value can only have one owner, and
    \item When the owner goes out of scope the variable is deleted~\cite{rust2023}.
\end{itemize}
Rust also employs a system of borrowing for referencing. When a variable needs to be used in a different part of code, say a function, 
\begin{itemize}
    \item The variable is borrowed by that function via a reference and does not own that variable,
    \item The function cannot return that reference, and
    \item The reference is deleted at the end of the function call because of ownership~\cite{rust2023}.
\end{itemize}
Rust also includes a very robust package manager and database, and build tool called “Cargo”~\cite{cargobook}. 
Cargo's package manager and crates.io makes community support for any features not included in the standard library to be maintained.
Rust's technology has allowed it to rank as the most popular language on Stack Overflow developer survey for seven years~\cite{stackoverflow2022}. 
The language has also amassed a large dedicated fanbase, including a discord server with 40,000+ users~\cite{discord}.
\par
Rust's potential in speed and lines of code (LOC) written helped raise the popularity of the language and brought about speed tests of the language. 
It has been run against C in the embedded software and determined to be a viable alternative~\cite{borgsmuller2021rust}. 
The safety benefits in systems programming has been explored~\cite{BalasubramanianProceedings}. 
Rust has also been compared to C, Fortran, and Java for speed and effort in parallel architectures, 
and found to be as fast as the fastest languages with the lowest amount of effort when programming~\cite{costanzo2021performance}\cite{heyman2020comparison}.
\par
The Sieve of Eratosthenes finds all prime numbers $p<n$ by starting at the first prime (normally 3) $p_0$ and multiplying by $k \leq \sqrt{n}$ where $k \in \mathbb{N}$ and marking resultant numbers as not prime.
When all $k$ have been multiplied by $p_0$ the steps are repeated on the next unmarked number $p_1$.
The extended Sieve of Eratosthenes divides the range of the sieve into segments of size $\sqrt{n}+1$ and mark prime numbers in the respective ranges one segment at a time.
Dave Plummer has run a Sieve of Eratosthenes “race” on many programming languages\cite{plummer}. 
Plummer's results show a basic Sieve as opposed to an extended sieve, and rather than testing speed, Plummer tested how many times 
the sieve can go up to a number in a certain amount of time. 
The sieve of Eratosthenes gives an excellent test of the languages standard library vector implementations, and ease of writing array code in each langauge.
\par
Approximating $\pi$ has been one of the longest problems in Mathematics, dating back to Ancient Egypt\cite{burton}. Methods for approximating $\pi$ have become quite computationally efficient since then and eventually 
lead to Ramunujan-type approximation by the Chudnovsky brotherswhich was used to break the the world record for computing $\pi$\cite{lynn}.
Approximating Euler's Number can be done through the Taylor Series derived from the equation $e^x$. Both these numerical approximations provide a great way to compare the compilation and LOC efficiency of Rust and C++, and external supported packages in each langauges.
\nocite{*}
\bibliographystyle{IEEEtran}
\bibliography{propbib}
\end{document}
