@mastersthesis{sudwoj2020rust,
  title  = {Rust programming language in the high-performance computing environment},
  author = {Sudwoj, Michal},
  type   = {{B.S.} thesis},
  year   = {2020},
  school = {ETH Zurich},
  url    = {https://doi.org/10.3929/ethz-b-000474922},
  annote = {
            \textbf{Overview:} This article compares the performance of Rust, C++, and Fortran implementations of the fourth-order numerical diffusion equation. They test solutions to this differential equation
            under many different conditions, techonologies, and compliers for each language when possible. They conclude that Rust is faster or just as fast as Fortran and C++. Additionally they find the features and
            safety of the langauge to be useful. \\
            \textbf{Evaluation:} This article has a lot of useful stuff, so much that it is hard to read it. Each test only being run once is not great, the hardware they run the tests on is quite old as well.
            It feels as though they are trying to do too much with this paper with how much was considered and tested. \\
            \textbf{Comments:} The performance tests here need to be run more times on newer hardware.
            }
}

@article{bugden2022rust,
  title   = {Rust: The programming language for safety and performance},
  author  = {Bugden, William and Alahmar, Ayman},
  journal = {arXiv preprint arXiv:2206.05503},
  year    = {2022},
  url     = {https://doi.org/10.48550/arXiv.2206.05503},
  annote  = {
             \textbf{Overview}: This article presents an summary of the Rust Programming langauge and analyzes the features that could be responsible for its rise in popularity.
             Rust achieves this through its high performance combined with its excellent memory safety features. Despite this Rust does not see as much use as older performant langauges like C and C++
             because of how new it is, even with its quickly growing follower-base. Thus, they recommend that more work be done to increase use of Rust among software engineers.\\
             \textbf{Evaluation:} A lot of good information in this article; although, pretty opinionated at times. Not much in terms of benchmarks or empiracal ways to measure the worth of a language.\\
             \textbf{Comments:} There is some nice to have info on Rust that I wish were here, like what a "panic" in rust actually does, and more info on ownership and the borrow-checker.
             }
}

@inproceedings{costanzo2021performance,
  author    = {Costanzo, Manuel and Rucci, Enzo and Naiouf, Marcelo and Giusti, Armando De},
  booktitle = {2021 XLVII Latin American Computing Conference (CLEI)},
  title     = {Performance vs Programming Effort between Rust and C on Multicore Architectures: Case Study in N-Body},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {1-10},
  url       = {https://doi.org/10.48550/arXiv.2107.11912},
  doi       = {10.48550/arXiv.2107.11912},
  annote    = {
               \textbf{Overview:} This article compares the performance of parallel computing speed of Rust and C in a gravitation N-Body problem.
               It compares many different variants of the Rust implementation, including use of different allocators, mathematical optimizations, use of different iterators,
               vectorizing with AVK-512, and block processing to the most optimized C implementaiton in 32 and 64 bit float implementation. They discovered that C was faster in 32 bit
               float simulations, but the langauges were equivalent in 64 bit float simulations. They also considered how the work done to implement the N-Body problem, finding it easier and faster
               in Rust once the langauge was understood. They suggest future work be done on other computationally intensive problems with different characteristics, including other programming langauges, and considering other CPU architectures. \\
               \textbf{Evaluation:} This is good; however, it focuses a lot on the optimization and consequences of having to deal with floats.
               }
}

@mastersthesis{heyman2020comparison,
  title  = {A comparison of performance \& implementation complexity of multithreaded applications in rust, java and c++},
  author = {Heyman, Hugo and Brandefelt, Love},
  type   = {{B.S.} thesis},
  year   = {2020},
  school = {KTH Royal Institute of Technology},
  url    = {http://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-280110},
  annote = {
            \textbf{Overview:} This article compares multithreaded performance in a key-value pair database developed in Rust, C++, and Java. Their implementation of a key-value pair was done through a hashmap.
            Performance tests were performend on read and writes to the database. They varied the number of read and writes done on the datase, as well the number of cores available to use. Read and write performance in Rust and C was about equivalent
            while Java was always the slowest. They also took into account how many lines of code each langauge used to create the database, with Rust being less than Java, and signifigantly less than C++. \\
            \textbf{Evaluation:} This is a nice and simple article. It is very focused on the analysis of key-value db performance. A big limitation is that the hardware used for testing is over a decade old.
            }
}


@inproceedings{BalasubramanianProceedings,
  author    = {Balasubramanian, Abhiram and Baranowski, Marek S. and Burtsev, Anton and Panda, Aurojit and Rakamari\'{c}, Zvonimir and Ryzhyk, Leonid},
  title     = {System Programming in Rust: Beyond Safety},
  year      = {2017},
  isbn      = {9781450350686},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3102980.3103006},
  doi       = {10.1145/3102980.3103006},
  abstract  = {Rust is a new system programming language that offers a practical and safe alternative to C. Rust is unique in that it enforces safety without runtime overhead, most importantly, without the overhead of garbage collection. While zero-cost safety is remarkable on its own, we argue that the superpowers of Rust go beyond safety. In particular, Rust's linear type system enables capabilities that cannot be implemented efficiently in traditional languages, both safe and unsafe, and that dramatically improve security and reliability of system software. We show three examples of such capabilities: zero-copy software fault isolation, efficient static information flow analysis, and automatic checkpointing. While these capabilities have been in the spotlight of systems research for a long time, their practical use is hindered by high cost and complexity. We argue that with the adoption of Rust these mechanisms will become commoditized.},
  booktitle = {Proceedings of the 16th Workshop on Hot Topics in Operating Systems},
  pages     = {156-161},
  numpages  = {6},
  location  = {Whistler, BC, Canada},
  series    = {HotOS '17},
  annote    = {
               \textbf{Overview:} This article compares system level performance and safety of Rust against C. Specifically looking at zero-copy software fault isolation, efficient static information flow analysis, and automatic checkpointing. \\
               \textbf{Evaluation:} Looks really into the advantages of Rust's types. It is also argued that the type advantages Rust has makes implementation and use more practical
               }
}